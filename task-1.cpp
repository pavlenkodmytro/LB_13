#include <iostream>  // Ввід/вивід
#include <cstdlib>   // Генерація випадкових чисел
#include <ctime>     // Робота з часом

using namespace std;

const int SIZE = 5; // Розмір матриці

int main() {
    srand(time(0)); // Ініціалізація генератора випадкових чисел

    int temporaryInt = 0; 
    int arr[SIZE][SIZE];  // Матриця 5x5
    int* ptr = &arr[temporaryInt][temporaryInt]; // Вказівник на перший елемент - &arr = адресу дістаємо

    // Заповнення матриці випадковими числами (1-99)
    for (int i = 0; i < SIZE * SIZE; i++) 
        *(ptr + i) = rand() % 100;// беремо фактичне значення поточного числа в ітерації *(ptr + i) де ptr - перший елемент. присвоюємо йому рандомне число

    // Виведення матриці
	// Зовнішній цикл for відповідає за рядки, внутрішній - за стовпці.
    cout << "Матриця:\n";
    for (int i = 0; i < SIZE; i++) { 
        for (int j = 0; j < SIZE; j++) 
            cout << *(ptr + i * SIZE + j) << "\t";
        cout << endl;
    }

    // Головна діагональ
        // Кожна ітерація циклу відповідає за виведення одного елемента головної діагоналі.
        // Зауважимо, що в квадратній матриці з розміром SIZE x SIZE
        // головна діагональ містить елементи, де номер рядка дорівнює номеру стовпця. 1 - 1.1 2 - 2.2ы і тд
    cout << "\nГоловна діагональ: ";
    for (int i = 0; i < SIZE; i++) 
        cout << *(ptr + i * (SIZE + 1)) << " ";
		
		
		
//		ptr — це вказівник на int (розмір int зазвичай 4 байти).
//      +6 означає переміщення вперед на 6 елементів типу int, а не просто додавання 6 байтів.
//      Оскільки int займає 4 байти, насправді ptr + 6 пересувається на 6 × 4 = 24 байти вперед у пам’яті.



// >arr[0][0]  arr[0][1]  arr[0][2]  arr[0][3]  arr[0][4]
// arr[1][0]  >arr[1][1]  arr[1][2]  arr[1][3]  arr[1][4]
// arr[2][0]  arr[2][1]  >arr[2][2]  arr[2][3]  arr[2][4]


    // Побічна діагональ
	// Та ж схема - (i+1)*(SIZE-1) це вираз, що в залежності від ітерації пересуває посилання на певну кількість елементів в масиві типу int.
    cout << "\nПобічна діагональ: ";
    for (int i = 0; i < SIZE; i++) 
        cout << *(ptr + (i + 1) * (SIZE - 1)) << " ";

    // Підрахунок парних та непарних чисел
	// в тернарку ми кидаємо *птр + і - фактичне значення поточного числа масиву в цій ітерації
    int evenCount = 0, oddCount = 0;
    for (int i = 0; i < SIZE * SIZE; i++) 
        (*(ptr + i) % 2 == 0) ? evenCount++ : oddCount++;

    cout << "\nПарні: " << evenCount << "\nНепарні: " << oddCount << endl;

    return 0;
}
