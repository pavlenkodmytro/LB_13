#include <iostream>     // Підключення бібліотеки для вводу/виводу. Забезпечує доступ до std::cout, std::endl тощо.
#include <cstdlib>      // Підключення бібліотеки для використання функції rand() для генерації випадкових чисел.
#include <ctime>        // Підключення бібліотеки для використання функції time(), яка допомагає ініціалізувати генератор випадкових чисел.
using namespace std;    // Використання простору імен std для уникнення префікса "std::" перед кожною стандартною функцією.

int main() {  
    // Визначаємо розміри матриці. Для прикладу використаємо квадратну матрицю 5х5.
    const int ROWS = 5;  // Кількість рядків
    const int COLS = 5;  // Кількість стовпців

    // Оголошення двовимірного масиву (матриці) з ROWS рядками і COLS стовпцями.
    // У цьому випадку пам'ять під матрицю виділяється на стеку і елементи будуть розташовані послідовно (рядковий порядок).
    int matrix[ROWS][COLS];

    // Ініціалізація генератора випадкових чисел.
    // Функція time(NULL) повертає поточний час, який використовується як початкове значення (seed) для генератора.
    // Це гарантує, що при кожному запуску програми послідовність випадкових чисел буде різною.
    srand(time(NULL));

    // Отримуємо вказівник на перший елемент матриці.
    // Оскільки масив "matrix" зберігається послідовно, &matrix[0][0] повертає адресу самого першого елемента.
    int *ptr = &matrix[0][0];
    
    // Обчислюємо загальну кількість елементів у матриці.
    int totalElements = ROWS * COLS;
    
    // Обчислюємо кінцеву адресу (адресу, що знаходиться після останнього елемента).
    // Арифметика вказівників враховує розмір типу int: ptr + totalElements перемістить вказівник на (totalElements * sizeof(int)) байтів.
    int *end = ptr + totalElements;
    
    // ============================================================
    // Заповнення матриці випадковими значеннями без використання індексації
    // ============================================================
    while (ptr < end) {
        // Оператор * розіменовує вказівник, тобто дозволяє доступ до значення за адресою, яку містить ptr.
        // Функція rand() повертає випадкове число, а оператор % 100 обмежує його значення діапазоном від 0 до 99.
        *ptr = rand() % 100;
        
        // Після присвоєння значення, збільшуємо вказівник ptr на 1. 
        // Оскільки ptr має тип int*, операція ptr++ додає до поточної адреси розмір одного int (наприклад, 4 байти).
        ptr++;
    }
    
    // Після заповнення матриці повертаємо вказівник до її початку, щоб мати можливість повторно обійти весь масив.
    ptr = &matrix[0][0];
    
    // ============================================================
    // Вивід елементів головної діагоналі
    // ============================================================
    // Головна діагональ містить елементи, для яких номер рядка дорівнює номеру стовпця.
    // У послідовно розміщеній матриці ці елементи розташовані за адресами: 
    // 0, (COLS+1), 2*(COLS+1), ..., (ROWS-1)*(COLS+1)
    cout << "Elements of MAIN diagonal :" << endl;
    // Отримуємо вказівник на перший елемент головної діагоналі.
    int *mainDiagPtr = &matrix[0][0];
    // Цикл, що проходить по кожному рядку матриці (тобто по кожному елементу головної діагоналі).
    for (int i = 0; i < ROWS; i++) {
        // Розіменування вказівника для виводу значення елемента.
        cout << *mainDiagPtr << " ";
        // Перехід до наступного елемента головної діагоналі.
        // Оскільки кожний наступний елемент розташовано на (COLS + 1) позицію далі у пам'яті,
        // додаємо COLS + 1 до поточної адреси.
        mainDiagPtr += COLS + 1;
    }
    cout << endl << endl;
    
    // ============================================================
    // Вивід елементів побічної діагоналі
    // ============================================================
    // Побічна (контр) діагональ містить елементи, для яких сума номера рядка та номера стовпця дорівнює (COLS - 1).
    // У квадратній матриці 5х5 це: (0,4), (1,3), (2,2), (3,1), (4,0)
    cout << "Elements of other diagonal:" << endl;
    // Отримуємо вказівник на перший елемент побічної діагоналі.
    // Початковий елемент розташований у верхньому правому куті, який знаходиться за адресою:
    // &matrix[0][0] + (COLS - 1). Арифметика вказівників дозволяє так обчислити адресу.
    int *secDiagPtr = &matrix[0][0] + (COLS - 1);
    // Проходимо по кожному рядку, отримуючи елементи побічної діагоналі.
    for (int i = 0; i < ROWS; i++) {
        cout << *secDiagPtr << " ";
        // Для переходу до наступного елемента побічної діагоналі:
        // - Спочатку переходимо на початок наступного рядка (адреса збільшується на COLS елементів),
        // - Потім рухаємося на один елемент лівіше (віднімаємо 1).
        // Отже, додаємо (COLS - 1) до поточної адреси.
        secDiagPtr += COLS - 1;
    }
    cout << endl << endl;
    
    // ============================================================
    // Підрахунок кількості парних та непарних елементів матриці
    // ============================================================
    // Повертаємо вказівник до початку матриці для повторного обходу.
    ptr = &matrix[0][0];
    
    // Ініціалізуємо лічильники для парних та непарних елементів.
    int evenCount = 0;
    int oddCount = 0;
    
    // Обходимо всю матрицю, використовуючи арифметику вказівників.
    while (ptr < end) {
        // Розіменування вказівника дає нам значення поточного елемента.
        // За допомогою оператора % перевіряємо, чи є число парним.
        if ((*ptr) % 2 == 0)
            evenCount++;   // Якщо залишок від ділення на 2 дорівнює 0 – число парне.
        else
            oddCount++;    // Інакше – число непарне.
        // Переходимо до наступного елемента, збільшуючи вказівник на розмір одного int.
        ptr++;
    }
    
    // ============================================================
    // Вивід результатів
    // ============================================================
    cout << "Amount of even nums: " << evenCount << endl;
    cout << "Amount of uneven nums: " << oddCount << endl;
    
    // Завершення роботи програми. Повернення 0 означає успішне виконання.
    return 0;
}
