#include <iostream>  // Підключаємо стандартну бібліотеку вводу/виводу для роботи з потоками (cout, endl).
#include <cstdlib>   // Підключаємо бібліотеку для загальних функцій, таких як rand() та srand().
#include <ctime>     // Підключаємо бібліотеку для роботи з часом; необхідно для генерації насіння для rand().
using namespace std; // Використовуємо простір імен std, щоб уникнути додаткового написання std:: перед кожною стандартною функцією.

int main() { // Початок основної функції, з якої починається виконання програми.
    // --- Оголошення та ініціалізація константних параметрів для матриці ---
    const int ROWS = 5; // Встановлюємо кількість рядків матриці; використання константи забезпечує незмінність значення.
    const int COLS = 5; // Встановлюємо кількість стовпців матриці.
    const int totalElements = ROWS * COLS; // Обчислюємо загальну кількість елементів матриці (5*5 = 25).

    // --- Динамічне виділення пам'яті для матриці ---
    // Виділяємо пам'ять для масиву з totalElements цілих чисел.
    int* matrix = new int[totalElements]; 
    // Пояснення: динамічне виділення пам'яті дозволяє створювати масив потрібного розміру під час виконання,
    // що особливо корисно, коли розмір масиву не відомий під час компіляції.

    // --- Ініціалізація генератора випадкових чисел ---
    // Використовуємо поточний час як насіння для генерації випадкових чисел, що гарантує різні результати при кожному запуску.
    srand(time(NULL));
    // Пояснення: time(NULL) повертає поточний час у секундах, а srand() ініціалізує генератор випадкових чисел.

    // --- Заповнення матриці випадковими числами ---
    // Встановлюємо вказівник ptr на початок масиву для обходу його елементів.
    int* ptr = matrix; 
    // Обчислюємо адресу, яка знаходиться одразу після останнього елемента масиву.
    int* end = matrix + totalElements;
    // Пояснення: Використання арифметики вказівників дозволяє ефективно обходити елементи масиву без індексів.
    while (ptr < end) { // Цикл триває доти, поки ptr не досягне адреси end.
        *ptr = rand() % 100; // Присвоюємо поточному елементу випадкове число від 0 до 99.
        // Пояснення: rand() генерує випадкове число, а оператор % обмежує його діапазон значень.
        ++ptr; // Зсуваємо вказівник на наступну позицію у масиві.
    }

    // --- Вивід згенерованої матриці ---
    cout << "Generated matrix:" << endl; // Виводимо заголовок, що повідомляє користувача про початок виводу матриці.
    // Переініціалізуємо вказівник ptr на початок масиву для виводу значень.
    ptr = matrix;
    // Зовнішній цикл для проходження по кожному рядку матриці.
    for (int i = 0; i < ROWS; i++) { // Цикл від 0 до ROWS-1 (5 рядків).
        // Внутрішній цикл для проходження по кожному стовпцю поточного рядка.
        for (int j = 0; j < COLS; j++) { // Цикл від 0 до COLS-1 (5 стовпців).
            cout << *ptr << " "; // Виводимо поточний елемент, розділяючи його пробілом.
            ++ptr; // Після виводу переміщуємо вказівник до наступного елемента.
        }
        cout << endl; // Після завершення рядка виводимо символ нового рядка для коректного форматування.
    }

    // --- Вивід елементів головної (основної) діагоналі матриці ---
    cout << "\nElements of MAIN diagonal:" << endl; // Виводимо заголовок для головної діагоналі з додатковим переходом на новий рядок.
    // Створюємо новий вказівник для обходу головної діагоналі, починаючи з першого елемента.
    int* mainDiagPtr = matrix;
    for (int i = 0; i < ROWS; i++) { // Оскільки матриця квадратна, проходимо по кожному рядку.
        cout << *mainDiagPtr << " "; // Виводимо елемент, що належить головній діагоналі.
        // Пояснення: в матриці, представленій у вигляді одномірного масиву, елементи головної діагоналі розташовані з інтервалом (COLS + 1).
        mainDiagPtr += COLS + 1; // Переміщуємо вказівник до наступного діагонального елемента.
    }
    cout << "\n\n"; // Додаємо два символи нового рядка для візуального розділення наступної частини виводу.

    // --- Вивід елементів побічної (іншої) діагоналі матриці ---
    cout << "Elements of OTHER diagonal:" << endl; // Виводимо заголовок для побічної діагоналі.
    // Розміщуємо вказівник secDiagPtr на останній елемент першого рядка (елемент з індексом COLS-1).
    int* secDiagPtr = matrix + (COLS - 1);
    for (int i = 0; i < ROWS; i++) { // Проходимо по кожному рядку для виводу побічної діагоналі.
        cout << *secDiagPtr << " "; // Виводимо поточний елемент побічної діагоналі.
        // Пояснення: для побічної діагоналі інтервал між елементами дорівнює (COLS - 1),
        // оскільки рух від верхнього правого до нижнього лівого елемента включає перехід на один рядок вниз і один стовпець вліво.
        secDiagPtr += COLS - 1; // Зсуваємо вказівник до наступного елемента побічної діагоналі.
    }
    cout << "\n\n"; // Додаємо символи нового рядка для кращого форматування виводу.

    // --- Підрахунок кількості парних та непарних чисел у матриці ---
    // Повертаємо вказівник ptr на початок масиву, щоб пройти по всіх елементах знову.
    ptr = matrix;
    int evenCount = 0, oddCount = 0; // Ініціалізуємо лічильники парних (evenCount) та непарних (oddCount) чисел значенням 0.
    while (ptr < end) { // Проходимо по всіх елементах матриці за допомогою вказівника.
        if (*ptr % 2 == 0) // Якщо поточне число ділиться на 2 без залишку, воно є парним.
            ++evenCount; // Збільшуємо лічильник парних чисел.
        else
            ++oddCount; // Якщо залишок не нульовий, число непарне, тому збільшуємо відповідний лічильник.
        ++ptr; // Переміщуємо вказівник на наступний елемент.
    }

    // --- Вивід результатів підрахунку ---
    cout << "Amount of even nums: " << evenCount << endl; // Виводимо кількість парних чисел.
    cout << "Amount of uneven nums: " << oddCount << endl;   // Виводимо кількість непарних чисел.

    // --- Звільнення динамічно виділеної пам'яті ---
    delete[] matrix; // Звільняємо пам'ять, виділену оператором new[], щоб уникнути витоків пам'яті.
    // Пояснення: Завжди важливо звільняти динамічно виділену пам'ять після її використання.

    // Повертаємо 0, що сигналізує про успішне завершення виконання програми.
    return 0; 
}
